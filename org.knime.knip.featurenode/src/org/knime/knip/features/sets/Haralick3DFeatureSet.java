/*
 * ------------------------------------------------------------------------
 *
 *  University of Konstanz, Germany and
 *  KNIME GmbH, Konstanz, Germany
 *  Website: http://www.knime.org; Email: contact@knime.org
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License, Version 3, as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, see <http://www.gnu.org/licenses>.
 *
 *  Additional permission under GNU GPL version 3 section 7:
 *
 *  KNIME interoperates with ECLIPSE solely via ECLIPSE's plug-in APIs.
 *  Hence, KNIME and ECLIPSE are both independent programs and are not
 *  derived from each other. Should, however, the interpretation of the
 *  GNU GPL Version 3 ("License") under any applicable laws result in
 *  KNIME and ECLIPSE being a combined program, KNIME GMBH herewith grants
 *  you the additional permission to use and propagate KNIME together with
 *  ECLIPSE with only the license terms in place for ECLIPSE applying to
 *  ECLIPSE and the GNU GPL Version 3 applying for KNIME, provided the
 *  license terms of ECLIPSE themselves allow for the respective use and
 *  propagation of ECLIPSE together with KNIME.
 *
 *  Additional permission relating to nodes for KNIME that extend the Node
 *  Extension (and in particular that are based on subclasses of NodeModel,
 *  NodeDialog, and NodeView) and that only interoperate with KNIME through
 *  standard APIs ("Nodes"):
 *  Nodes are deemed to be separate and independent programs and to not be
 *  covered works.  Notwithstanding anything to the contrary in the
 *  License, the License does not apply to Nodes, you are not required to
 *  license Nodes under the License, and you are granted a license to
 *  prepare and propagate Nodes, in each case even if such Nodes are
 *  propagated with or for interoperation with KNIME.  The owner of a Node
 *  may freely choose the license terms applicable to such Node, including
 *  when such Node is propagated with or for interoperation with KNIME.
  ---------------------------------------------------------------------
 *
 */

package org.knime.knip.features.sets;

import org.scijava.ItemIO;
import org.scijava.convert.AbstractConverter;
import org.scijava.convert.ConversionRequest;
import org.scijava.convert.Converter;
import org.scijava.plugin.Attr;
import org.scijava.plugin.Parameter;
import org.scijava.plugin.Plugin;

import net.imagej.ops.Contingent;
import net.imagej.ops.features.haralick.HaralickFeature;
import net.imagej.ops.image.cooccurrencematrix.MatrixOrientation3D;
import net.imglib2.IterableInterval;
import net.imglib2.type.numeric.RealType;

/**
 * {@link FeatureSet} for {@link HaralickFeature}s
 * 
 * @author Christian Dietz, University of Konstanz
 * @param <T>
 * @param <O>
 */
@Plugin(type = FeatureSet.class, label = "Haralick 3D Features", description = "<h1> Haralick 3D Feature Set</h1> <h2>Description</h2> The basis for these features is the gray-level co-occurrence matrix. This matrix is square with dimension Ng, where Ng is the number of gray levels in the image. Element [i,j] of the matrix is generated by counting the number of times a pixel with value i is adjacent to a pixel with value j and then dividing the entire matrix by the total number of such comparisons made. Each entry is therefore considered to be the probability that a pixel with value i will be found adjacent to a pixel of value j. For more information see <a href=\"http://murphylab.web.cmu.edu/publications/boland/boland_node26.html\">Haralick Features</a><h2>Parameters</h2> <ul><li><strong>Num. Grey Levels:</strong> The number of grey values determines the size of the co-occurence matrix on which the Haralick features are calculated.</li><li><strong>Distance:</strong> The maximum distance between pairs of pixels which will be added to the co-occurence matrix.</li><li><strong>Orientation:</strong> Orientation of the pairs of pixels which will be added to the co-occurence matrix.</li></ul>")
public class Haralick3DFeatureSet<T extends RealType<T>, O extends RealType<O>>
		extends AbstractOpRefFeatureSet<IterableInterval<T>, O> implements Contingent {

	private static final String PKG = "net.imagej.ops.Ops$Haralick$";

	@Parameter(type = ItemIO.INPUT, label = "Num. Grey Levels", description = "The number of grey values determines the size of the co-occurence matrix on which the Haralick features are calculated.", min = "1", max = "2147483647", stepSize = "1")
	private int numGreyLevels = 32;

	@Parameter(type = ItemIO.INPUT, label = "Distance", description = "The maximum distance between pairs of pixels which will be added to the co-occurence matrix.", min = "1", max = "2147483647", stepSize = "1")
	private int distance = 1;

	@Parameter(type = ItemIO.INPUT, label = "Orientation", description = "Orientation of the pairs of pixels which will be added to the co-occurence matrix", choices = {
			"HORIZONTAL", "VERTICAL", "DIAGONAL", "ANTIDIAGONAL", "HORIZONTAL_VERTICAL", "HORIZONTAL_DIAGONAL",
			"VERTICAL_VERTICAL", "VERTICAL_DIAGONAL", "DIAGONAL_VERTICAL", "DIAGONAL_DIAGONAL", "ANTIDIAGONAL_VERTICAL",
			"ANTIDIAGONAL_DIAGONAL", "DEPTH" })
	private String orientation = "HORIZONTAL";

	@Parameter(required = false, label = "ASM", attrs = { @Attr(name = ATTR_FEATURE),
			@Attr(name = ATTR_PARAMS, value = "numGreyLevels,distance,orientation"),
			@Attr(name = ATTR_TYPE, value = PKG + "ASM") })
	private boolean isASMActive = true;

	@Parameter(required = false, label = "Cluster Promenence", attrs = { @Attr(name = ATTR_FEATURE),
			@Attr(name = ATTR_PARAMS, value = "numGreyLevels,distance,orientation"),
			@Attr(name = ATTR_TYPE, value = PKG + "ClusterPromenence") })
	private boolean isClusterPromenenceActive = true;

	@Parameter(required = false, label = "Cluster Shade", attrs = { @Attr(name = ATTR_FEATURE),
			@Attr(name = ATTR_PARAMS, value = "numGreyLevels,distance,orientation"),
			@Attr(name = ATTR_TYPE, value = PKG + "ClusterShade") })
	private boolean isClusterShadeActive = true;

	@Parameter(required = false, label = "Cluster Contrast", attrs = { @Attr(name = ATTR_FEATURE),
			@Attr(name = ATTR_PARAMS, value = "numGreyLevels,distance,orientation"),
			@Attr(name = ATTR_TYPE, value = PKG + "Contrast") })
	private boolean isContrastActive = true;

	@Parameter(required = false, label = "Correlation", attrs = { @Attr(name = ATTR_FEATURE),
			@Attr(name = ATTR_PARAMS, value = "numGreyLevels,distance,orientation"),
			@Attr(name = ATTR_TYPE, value = PKG + "Correlation") })
	private boolean isCorrelationActive = true;

	@Parameter(required = false, label = "Difference Entropy", attrs = { @Attr(name = ATTR_FEATURE),
			@Attr(name = ATTR_PARAMS, value = "numGreyLevels,distance,orientation"),
			@Attr(name = ATTR_TYPE, value = PKG + "DifferenceEntropy") })
	private boolean isDifferenceEntropyActive = true;

	@Parameter(required = false, label = "Difference Variance", attrs = { @Attr(name = ATTR_FEATURE),
			@Attr(name = ATTR_PARAMS, value = "numGreyLevels,distance,orientation"),
			@Attr(name = ATTR_TYPE, value = PKG + "DifferenceVariance") })
	private boolean isDifferenceVarianceActive = true;

	@Parameter(required = false, label = "Entropy", attrs = { @Attr(name = ATTR_FEATURE),
			@Attr(name = ATTR_PARAMS, value = "numGreyLevels,distance,orientation"),
			@Attr(name = ATTR_TYPE, value = PKG + "Entropy") })
	private boolean isEntropyActive = true;

	@Parameter(required = false, label = "ICM1", attrs = { @Attr(name = ATTR_FEATURE),
			@Attr(name = ATTR_PARAMS, value = "numGreyLevels,distance,orientation"),
			@Attr(name = ATTR_TYPE, value = PKG + "ICM1") })
	private boolean isICM1Active = true;

	@Parameter(required = false, label = "ICM2", attrs = { @Attr(name = ATTR_FEATURE),
			@Attr(name = ATTR_PARAMS, value = "numGreyLevels,distance,orientation"),
			@Attr(name = ATTR_TYPE, value = PKG + "ICM2") })
	private boolean isICM2Active = true;

	@Parameter(required = false, label = "IFDM", attrs = { @Attr(name = ATTR_FEATURE),
			@Attr(name = ATTR_PARAMS, value = "numGreyLevels,distance,orientation"),
			@Attr(name = ATTR_TYPE, value = PKG + "IFDM") })
	private boolean isIFDMActive = true;

	@Parameter(required = false, label = "Max Probability", attrs = { @Attr(name = ATTR_FEATURE),
			@Attr(name = ATTR_PARAMS, value = "numGreyLevels,distance,orientation"),
			@Attr(name = ATTR_TYPE, value = PKG + "MaxProbability") })
	private boolean isMaxProbabilityActive = true;

	@Parameter(required = false, label = "Sum Average", attrs = { @Attr(name = ATTR_FEATURE),
			@Attr(name = ATTR_PARAMS, value = "numGreyLevels,distance,orientation"),
			@Attr(name = ATTR_TYPE, value = PKG + "SumAverage") })
	private boolean isSumAverageActive = true;

	@Parameter(required = false, label = "Sum Entropy", attrs = { @Attr(name = ATTR_FEATURE),
			@Attr(name = ATTR_PARAMS, value = "numGreyLevels,distance,orientation"),
			@Attr(name = ATTR_TYPE, value = PKG + "SumEntropy") })
	private boolean isSumEntropyActive = true;

	@Parameter(required = false, label = "Sum Variance", attrs = { @Attr(name = ATTR_FEATURE),
			@Attr(name = ATTR_PARAMS, value = "numGreyLevels,distance,orientation"),
			@Attr(name = ATTR_TYPE, value = PKG + "SumVariance") })
	private boolean isSumVarianceActive = true;

	@Parameter(required = false, label = "Texture Homogenity", attrs = { @Attr(name = ATTR_FEATURE),
			@Attr(name = ATTR_PARAMS, value = "numGreyLevels,distance,orientation"),
			@Attr(name = ATTR_TYPE, value = PKG + "TextureHomogeneity") })
	private boolean isTextureHomogeneityActive = true;

	@Parameter(required = false, label = "Variance", attrs = { @Attr(name = ATTR_FEATURE),
			@Attr(name = ATTR_PARAMS, value = "numGreyLevels,distance,orientation"),
			@Attr(name = ATTR_TYPE, value = PKG + "Variance") })
	private boolean isVarianceActive = true;

	@Override
	public boolean conforms() {
		return in().numDimensions() == 3;
	}

	@Override
	public boolean isCompatible(final Class<?> object, final Class<?> type) {
		return IterableInterval.class.isAssignableFrom(object) && RealType.class.isAssignableFrom(type);
	}

	@Plugin(type = Converter.class)
	public static class StringToMatrixOrientation3D extends AbstractConverter<String, MatrixOrientation3D> {

		@SuppressWarnings("unchecked")
		@Override
		public <T> T convert(Object src, Class<T> dest) {
			return (T) MatrixOrientation3D.valueOf(((String) src));
		}

		@Override
		public Class<MatrixOrientation3D> getOutputType() {
			return MatrixOrientation3D.class;
		}

		@Override
		public Class<String> getInputType() {
			return String.class;
		}

		@Override
		public boolean canConvert(ConversionRequest request) {
			return canConvert(request.sourceObject(), request.destClass());
		}

		@Override
		public boolean canConvert(final Object src, Class<?> dest) {
			if (!(src instanceof String)) {
				return false;
			}

			final String toTest = (String) src;
			for (MatrixOrientation3D matrix : MatrixOrientation3D.values()) {
				if (matrix.toString().equals(toTest)) {
					return super.canConvert(src, dest);
				}
			}
			return false;
		}
	}

}
